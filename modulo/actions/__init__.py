#!/usr/bin/python

'''Infrastructure for the action architecture.

"Action architecture" reflects the fact that in a dynamic web application,
a single page is typically generated by putting together several different sources
of information: database queries, template files, static data files, maybe some
information from a cache, or something wacky and completely application-specific.
Different properties combine in different ways - for instance, the modification
time of a page is the latest modification time of any of the resources involved
in creating it, the credentials required to access a protected page should
be the union of the credentials required to access each resource, etc. etc. etc.
Most web programming environments don't seem to be designed with this architecture
in mind; you can still see remnants (sometimes strong remnants) of the old
static-file approach, where all the content and metadata come from one source,
either a static file or a CGI script. In contrast, the action architecture
lets you specify the content and properties of each resource individually,
and the system takes care of putting them together.'''

import os
import random
import re
import time
import urlparse
import weakref
from modulo.utilities import hash_iterable
from os.path import dirname, isfile, join, splitext
from stat import ST_MTIME
from werkzeug import BaseRequest

__all__ = ['all_of', 'any_of', 'opt', 'Action']

def all_of(*cls):
    '''Creates an Action subclass that passes requests to all given classes.

    The returned subclass is called AllActions_<hash value>, where <hash value> is
    a deterministic function of the arguments. It delegates calls to handles()
    to its constituent classes (the parameters given in cls) such that it only
    accepts the request (returns True) if *all* constituent classes individually
    accept the request. When an instance of AllActions is created, it internally
    also creates instances of all its constituent classes to which it will delegate
    calls to update_mtime() and generate().

    If one of the parameters to this method is itself a subclass of AllActions,
    its list of constituent classes, rather than the parameter class itself, will
    be copied into the new AllActions. This reduces the total number of instances
    of AllActions necessary.'''
    handler_classes = []
    for n in cls:
        if not issubclass(n, Action):
            return NotImplemented
        if isinstance(n, AllActions):
            handler_classes.extend(n.handler_classes)
        else:
            handler_classes.append(n)
    # Use the metaclass to create a dynamic subclass of AllActions
    # with our list of handler classes.
    return ActionMetaclass('AllActions_%s' % hash_iterable(handler_classes), (AllActions,), {'handler_classes': handler_classes})

def any_of(*cls):
    '''Creates an Action subclass that passes requests to one of the given classes.

    The returned subclass is called AnyAction_<hash value>, where <hash value> is
    a deterministic function of the arguments. It delegates calls to handles() to
    its constituent classes (the parameters given in cls) such that it accepts the
    request (returns True) if *any* of the constituent classes individually accept
    the request. Instances of AnyAction are never actually created; when you
    construct a AnyAction for a given request, what you actually get is an
    instance of the first constituent class which has agreed to handle the request.

    If one of the parameters to this method is itself a subclass of AnyAction,
    its list of constituent classes, rather than the parameter class itself, will
    be copied into the new AnyAction. This reduces the total number of instances
    of AnyAction necessary.'''
    handler_classes = []
    for n in cls:
        if not issubclass(n, Action):
            return NotImplemented
        if isinstance(n, AnyAction):
            handler_classes.extend(n.handler_classes)
        else:
            handler_classes.append(n)
    return type('AnyAction_%s' % hash_iterable(handler_classes), (AnyAction,), {'handler_classes': handler_classes})

def opt(cls):
    '''Creates an Action subclass that wraps a given handler class to make it optional.

    The returned subclass is called OptAction_<hash value>, where <hash value> is a
    deterministic function of the argument. It returns True from handles(req) for all
    requests, but if its constituent class (the parameter given in cls) doesn't actually
    handle the request, attempting to create an instance of OptAction returns a NoopHandler
    (which does nothing) instead. If the constituent class does handle the request, than an
    instance of it itself is created and returned.

    If the parameter to this method is itself a subclass of OptAction, then it will be
    returned itself, rather than a new OptAction being created to wrap it.'''
    if not issubclass(cls, Action):
        return NotImplemented
    elif cls.__name__.startswith('OptAction'):
        return cls
    else:
        return ActionMetaclass('OptAction_%s' % hash_iterable([cls]), (OptAction,), {'handler_class': cls})

class ActionMetaclass(type):
    '''A metaclass that grants composition methods to the Action class itself.'''
    __and__ = all_of
    __or__ = any_of
    __invert__ = opt

    # Python voodoo ;-) make Action() call Action.derive() and Action.handle() call Action()
    def __call__(self, *args, **kwargs):
        return self.derive(*args, **kwargs)

    def handle(self, req):
        req.loggers['modulo'].debug('in %s.handle(%s)', self, req)
        return super(ActionMetaclass, self).__call__(req)

# more Python voodoo! Use a descriptor so that the method will be either a static method
# or instance method depending on whether we call it from the class or an instance
class LoggingDescriptor(object):
    def __init__(self, method_name):
        super(LoggingDescriptor, self).__init__()
        self.method_name = method_name

    def __get__(self, instance, owner):
        if instance is None:
            logger_name = getattr(owner, '__logger__', 'modulo')
            def log(req, *args, **kwargs):
                return getattr(req.loggers[logger_name], self.method_name)(*args, **kwargs)
        else:
            logger_name = getattr(instance, '__logger__', 'modulo')
            def log(*args, **kwargs):
                return getattr(instance.req.loggers[logger_name], self.method_name)(*args, **kwargs)
        return log

class Action(object):
    '''Represents an action that can be taken by the server.

    A web application is created by constructing a tree of these objects. Each time a
    request comes in, it is passed to each one in turn to give that handler a chance
    to do whatever it needs to do with the request. Note that this allows multiple
    handlers to run, each modifying the request in some manner, so typically the
    response that winds up being returned to the client is a composite thing put
    together from different parts provided by different handlers.'''
    __metaclass__ = ActionMetaclass

    debug = LoggingDescriptor('debug')
    info = LoggingDescriptor('info')
    warning = LoggingDescriptor('warning')
    error = LoggingDescriptor('error')
    critical = LoggingDescriptor('critical')
    exception = LoggingDescriptor('exception')
    log = LoggingDescriptor('log')

    @classmethod
    def derive(cls, **kwargs):
        '''Returns a subclass of this class with selected class variables set.

        This is useful for certain subclasses which take configuration information
        from class variables. If they were instance variables, you could create an
        instance of the class and set the values of the variables to whatever you
        want, but they're not instance variables, so in order to get custom behavior
        we use subclasses instead of instances. This method will dynamically generate
        a subclass of the current class with selected properties overridden. The
        subclass will have a name of the form <class name>_<hash value> where
        <class name> is the name of this class and <hash value> is some deterministic
        function of the keys and values in args and kwargs. (The specific hash
        function used is purposely undocumented and may change; in practice it
        should probably never be necessary to know the hash generated)

        If you write a subclass of Action that uses class variables, I suggest
        overriding derive like this to specify which properties your class takes/needs:

            def derive(cls, <property1>, <property2>, ...):
                return super(<class>, cls).derive(<property1>=<property1>, <property2>=<property2>, ...)

        Just replace property1, property2, etc. in all three spots with the name of
        each property, and <class> with the name of the class. It's boilerplate
        code but there doesn't seem to be any way to reduce it further than this.'''
        return type('%s_%s' % (cls.__name__, hash_iterable(kwargs)), (cls,), kwargs)

    def __new__(cls, req):
        if cls.handles(req):
            return super(Action, cls).__new__(cls, req)
        else:
            return None

    @classmethod
    def handles(cls, req):
        '''Indicates whether this handler can handle the given request.

        If this method returns False, all operations on this handler for this
        request will be skipped. This includes computation of the last modified date.

        This is the very first thing to be called on a handler for a given request.
        It should not have any side effects.

        The default behavior is to return True, so handlers will accept all requests
        by default.'''
        return True

    def __init__(self, req):
        '''Initializes the handler.'''
        super(Action, self).__init__()
        self.req = req

    def transform(self):
        '''An opportunity for this Action to transform the request. The return
        value from this method should be a Werkzeug Request, which will be used in
        place of the original request object when asking actions to handle the
        request. This can be used to implement things like consuming path components.

        By default this method just returns the argument req without any modification.'''
        return self.req

    def authorized(self):
        '''Return True if the current request is authorized to access this action, False if not'''
        return True

    def last_modified(self):
        '''Return the last modification time of the current action as a datetime object.'''
        return datetime.datetime()

    def action_id(self):
        '''Return a deterministic ID for the current action, used in generating the
        Etag. The ID should reflect the content generated by the action (i.e. if the
        action generates different content for two different requests, it should
        provide a different ID for each).'''
        return 0

    def generate(self, rsp):
        '''Generates the portion of the response, or generally takes whatever action
        is necessary for this action.

        This method is supposed to include any expensive content generation procedure
        that should be skipped if, for example, the client already has the response
        cached. So if this method is called at all for a given request, it's an
        indication that the Last-Modified header has been computed and checked against
        any If-Modified-Since sent by the client, and it's been determined that we
        do need to create and send a new response. This method can and should access
        its data from a cache if appropriate, rather than automatically running some
        expensive database access or such every time.

        If this method throws any exception it will be trapped and a 500 error page
        will be generated.'''
        pass

class HashKey(object):
    '''A surrogate key for objects which are not themselves hashable'''
    def __new__(cls, req):
        try:
            hk = req.hashkey
        except AttributeError:
            hk = req.hashkey = super(HashKey, cls).__new__(cls, req)
        return hk

    def __init__(self, req):
        if not hasattr(self, 'hashcode'):
            self.hashcode = hash(random.getrandbits(32))

    def __hash__(self):
        return self.hashcode

class AllActions(Action):
    handler_classes = []
    handler_cache = weakref.WeakKeyDictionary()

    @classmethod
    def handles(cls, req):
        if HashKey(req) in cls.handler_cache:
            return True
        # short way
        #return all(hc.handles(req) for hc in cls.handler_classes)
        # verbose way
        for hc in cls.handler_classes:
            if not hc.handles(req):
                cls.debug(req, '%s rejecting request %s (returning)' % (hc, req))
                return False
            else:
                cls.debug(req, '%s accepting request %s' % (hc, req))
        return True

    def __new__(cls, req):
        handlers = []
        for hc in cls.handler_classes:
            h = hc.handle(req)
            if h is None:
                pass
            elif isinstance(h, AllActions):
                handlers.extend(h.handlers)
                del h
            else:
                handlers.append(h)
                req = h.transform()
                assert isinstance(req, BaseRequest)
        if len(handlers) == 1:
            return handlers[0]
        elif len(handlers) == 0:
            return None
        else:
            cls.handler_cache[HashKey(req)] = handlers
            return super(AllActions, cls).__new__(cls, req)

    def __init__(self, req):
        super(AllActions, self).__init__(req)
        self.handlers = self.handler_cache.pop(HashKey(req))

    def __del__(self):
        del self.handlers

    def __str__(self):
        self_string = super(AllActions, self).__str__() + "\n"
        sub_string = ''.join(''.join("  %s\n" % l for l in str(h).splitlines()) for h in self.handlers)
        return self_string + sub_string

    def authorized(self):
        return all(h.authorized() for h in self.handlers)

    def last_modified(self):
        return max(h.last_modified() for h in self.handlers)

    def action_id(self):
        return hash_iterable(filter(None, (h.action_id() for h in self.handlers)))

    def generate(self, rsp):
        for h in self.handlers:
            if h.generate(rsp):
                return True

class AnyAction(Action):
    handler_classes = []

    # Every handler class that gets added to the dictionary (in handles()) should eventually
    # be removed (in __new__()), but in case there's some leak by which that doesn't occur,
    # we don't want the dictionary to grow large. So we use weak references to the requests,
    # that way at the very latest, each dict entry will be deleted when the request is
    # finished processing.
    handler_cls_cache = weakref.WeakKeyDictionary()

    @classmethod
    def handles(cls, req):
        hk = HashKey(req)
        if hk in cls.handler_cls_cache:
            return True
        for hc in cls.handler_classes:
            if hc.handles(req):
                cls.debug(req, '%s accepting request %s (returning)' % (hc, req))
                cls.handler_cls_cache[hk] = hc
                return True
            else:
                cls.debug(req, '%s rejecting request %s' % (hc, req))
        return False

    def __new__(cls, req):
        if cls.handles(req):
            return (cls.handler_cls_cache.pop(HashKey(req))).handle(req)
        else:
            return None

class OptAction(Action):
    @classmethod
    def handles(cls, req):
        return True

    def __new__(cls, req):
        return cls.handler_class(req) or None
