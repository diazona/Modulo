#!/usr/bin/python

'''Infrastructure for the resource architecture.

"Resource architecture" reflects the fact that in a dynamic web application,
a single page is typically generated by putting together several different sources
of information: database queries, template files, static data files, maybe some
information from a cache, or something wacky and completely application-specific.
Different properties combine in different ways - for instance, the modification
time of a page is the latest modification time of any of the resources involved
in creating it, the credentials required to access a protected page should
be the union of the credentials required to access each resource, etc. etc. etc.
Most web programming environments don't seem to be designed with this architecture
in mind; you can still see remnants (sometimes strong remnants) of the old
static-file approach, where all the content and metadata come from one source,
either a static file or a CGI script. In contrast, the resource architecture
lets you specify the content and properties of each resource individually,
and the system takes care of putting them together.'''

import os
import random
import re
import time
import urlparse
import weakref
from modulo.utilities import hash_iterable
from os.path import dirname, isfile, join, splitext
from stat import ST_MTIME
from werkzeug import BaseRequest

__all__ = ['all_of', 'any_of', 'opt', 'Resource']

def all_of(*cls):
    '''Creates a Resource subclass that passes requests to all given classes.

    The returned subclass is called AllResources_<hash value>, where <hash value> is
    a deterministic function of the arguments. It delegates calls to handles()
    to its constituent classes (the parameters given in cls) such that it only
    accepts the request (returns True) if *all* constituent classes individually
    accept the request. When an instance of AllResources is created, it internally
    also creates instances of all its constituent classes to which it will delegate
    calls to update_mtime() and generate().

    If one of the parameters to this method is itself a subclass of AllResources,
    its list of constituent classes, rather than the parameter class itself, will
    be copied into the new AllResources. This reduces the total number of instances
    of AllResources necessary.'''
    handler_classes = []
    for n in cls:
        if not issubclass(n, Resource):
            return NotImplemented
        if n.__name__.startswith('AllResources_'):
            handler_classes.extend(n.handler_classes)
        else:
            handler_classes.append(n)
    # Use the metaclass to create a dynamic subclass of AllResources
    # with our list of handler classes.
    return ResourceMetaclass('AllResources_%s' % hash_iterable(handler_classes), (AllResources,), {'handler_classes': handler_classes})

def any_of(*cls):
    '''Creates a Resource subclass that passes requests to one of the given classes.

    The returned subclass is called AnyResource_<hash value>, where <hash value> is
    a deterministic function of the arguments. It delegates calls to handles() to
    its constituent classes (the parameters given in cls) such that it accepts the
    request (returns True) if *any* of the constituent classes individually accept
    the request. Instances of AnyResource are never actually created; when you
    construct a AnyResource for a given request, what you actually get is an
    instance of the first constituent class which has agreed to handle the request.

    If one of the parameters to this method is itself a subclass of AnyResource,
    its list of constituent classes, rather than the parameter class itself, will
    be copied into the new AnyResource. This reduces the total number of instances
    of AnyResource necessary.'''
    handler_classes = []
    for n in cls:
        if not issubclass(n, Resource):
            return NotImplemented
        if n.__name__.startswith('AnyResource_'):
            handler_classes.extend(n.handler_classes)
        else:
            handler_classes.append(n)
    return type('AnyResource_%s' % hash_iterable(handler_classes), (AnyResource,), {'handler_classes': handler_classes})

def opt(cls):
    '''Creates a Resource subclass that wraps a given handler class to make it optional.

    The returned subclass is called OptResource_<hash value>, where <hash value> is a
    deterministic function of the argument. It returns True from handles(req) for all
    requests, but if its constituent class (the parameter given in cls) doesn't actually
    handle the request, attempting to create an instance of OptResource returns a NoopHandler
    (which does nothing) instead. If the constituent class does handle the request, than an
    instance of it itself is created and returned.

    If the parameter to this method is itself a subclass of OptResource, then it will be
    returned itself, rather than a new OptResource being created to wrap it.'''
    if not issubclass(cls, Resource):
        return NotImplemented
    elif cls.__name__.startswith('OptResource'):
        return cls
    else:
        return ResourceMetaclass('OptResource_%s' % hash_iterable([cls]), (OptResource,), {'handler_class': cls})

class ResourceMetaclass(type):
    '''A metaclass that grants composition methods to the ResourceHandler class itself.'''
    __and__ = all_of
    __or__ = any_of
    __invert__ = opt

class Resource(object):
    '''Represents a resource that can be served by the server.

    A web application is created by constructing a tree of these objects. Each time a
    request comes in, it is passed to each one in turn to give that handler a chance
    to do whatever it needs to do with the request. Note that this allows multiple
    handlers to run, each modifying the request in some manner, so typically the
    response that winds up being returned to the client is a composite thing put
    together from different parts provided by different handlers.'''
    __metaclass__ = ResourceMetaclass

    def __new__(cls, req):
        if cls.handles(req):
            return super(Resource, cls).__new__(cls, req)
        else:
            return None

    @classmethod
    def handles(self, req):
        '''Indicates whether this handler can handle the given request.

        If this method returns False, all operations on this handler for this
        request will be skipped. This includes computation of the last modified date.

        This is the very first thing to be called on a handler for a given request.
        It should not have any side effects.

        The default behavior is to return True, so handlers will accept all requests
        by default.'''
        return True

    @classmethod
    def derive(cls, **kwargs):
        '''A convenience function to create a custom subclass of ResourceHandler.

        This is useful for certain subclasses which take configuration information
        from class variables. Since it's not possible to customize those values by
        creating an instance of something and passing arguments to its constructor
        or setting properties on it (the way you'd customize instance variables),
        in order to get custom behavior we need to use subclasses. This method will
        dynamically generate a subclass of the current class with selected properties
        overridden. The subclass will have a name of the form <class name>_<hash value>
        where <class name> is the name of this class and <hash value> is some
        deterministic function of the keys and values in kwargs. (The specific hash
        function used is purposely undocumented and may change)'''
        return type('%s_%s' % (cls.__name__, hash_iterable(kwargs)), (cls,), kwargs)

    def __init__(self, req):
        '''Initializes the handler.'''
        super(Resource, self).__init__()
        self.req = req

    def transform(self):
        '''An opportunity for this Resource to transform the request. The return
        value from this method should be a Werkzeug Request, which will be used in
        place of the original request object when asking resources to handle the
        request. This can be used to implement things like consuming path components.

        By default this method just returns the argument req without any modification.'''
        return self.req

    def authorized(self):
        '''Return True if the current request is authorized to access this resource, False if not'''
        return True

    def last_modified(self):
        '''Return the last modification time of the current resource as a datetime object.'''
        return datetime.datetime()

    def resource_id(self):
        '''Return a deterministic ID for the current resource, used in generating the
        Etag. The ID should reflect the content generated by the resource (i.e. if the
        resource generates different content for two different requests, it should
        provide a different ID for each).'''
        return 0

    def generate(self, rsp):
        '''Generates the portion of the response, or generally takes whatever action
        is necessary for this resource.

        This method is supposed to include any expensive content generation procedure
        that should be skipped if, for example, the client already has the response
        cached. So if this method is called at all for a given request, it's an
        indication that the Last-Modified header has been computed and checked against
        any If-Modified-Since sent by the client, and it's been determined that we
        do need to create and send a new response. This method can and should access
        its data from a cache if appropriate, rather than automatically running some
        expensive database access or such every time.

        If this method throws any exception it will be trapped and a 500 error page
        will be generated.'''
        pass

class HashKey(object):
    '''A surrogate key for objects which are not themselves hashable'''
    def __new__(cls, req):
        try:
            hk = req.hashkey
        except AttributeError:
            hk = req.hashkey = super(HashKey, cls).__new__(cls, req)
        return hk

    def __init__(self, req):
        if not hasattr(self, 'hashcode'):
            self.hashcode = hash(random.getrandbits(32))

    def __hash__(self):
        return self.hashcode

class AllResources(Resource):
    handler_classes = []
    handler_cache = weakref.WeakKeyDictionary()

    @classmethod
    def handles(cls, req): # is this actually used?
        return all(hc.handles(req) for hc in cls.handler_classes)

    def __new__(cls, req):
        handlers = []
        for hc in cls.handler_classes:
            h = hc(req)
            if h is None:
                pass
            elif isinstance(h, AllResources):
                handlers.extend(h.handlers)
                del h
            else:
                handlers.append(h)
                req = h.transform()
                assert isinstance(req, BaseRequest)
        if len(handlers) == 1:
            return handlers[0]
        elif len(handlers) == 0:
            return None
        else:
            cls.handler_cache[HashKey(req)] = handlers
            return super(AllResources, cls).__new__(cls, req)

    def __init__(self, req):
        super(AllResources, self).__init__(req)
        self.handlers = self.handler_cache.pop(HashKey(req))

    def __del__(self):
        del self.handlers

    def __str__(self):
        self_string = super(AllResources, self).__str__() + "\n"
        sub_string = ''.join(''.join("  %s\n" % l for l in str(h).splitlines()) for h in self.handlers)
        return self_string + sub_string

    def authorized(self):
        return all(h.authorized() for h in self.handlers)

    def last_modified(self):
        return max(h.last_modified() for h in self.handlers)

    def resource_id(self):
        return hash_iterable(filter(None, (h.resource_id() for h in self.handlers)))

    def generate(self, rsp):
        for h in self.handlers:
            if h.generate(rsp):
                return True

class AnyResource(Resource):
    handler_classes = []

    # Every handler class that gets added to the dictionary (in handles()) should eventually
    # be removed (in __new__()), but in case there's some leak by which that doesn't occur,
    # we don't want the dictionary to grow large. So we use weak references to the requests,
    # that way at the very latest, each dict entry will be deleted when the request is
    # finished processing.
    handler_cls_cache = weakref.WeakKeyDictionary()

    @classmethod
    def handles(cls, req):
        hk = HashKey(req)
        if hk in cls.handler_cls_cache:
            return True
        for hc in cls.handler_classes:
            if hc.handles(req):
                cls.handler_cls_cache[hk] = hc
                return True
        return False

    def __new__(cls, req):
        if cls.handles(req):
            return (cls.handler_cls_cache.pop(HashKey(req)))(req)
        else:
            return None

class OptResource(Resource):
    @classmethod
    def handles(cls, req):
        return True

    def __new__(cls, req):
        return cls.handler_class(req) or None
